# FINAL VErsion of the FLASK DATASTORE GNIB VISA CHECKER! :-{#  export GCLOUD_PROJECT=flask-datastore-test# [START app]import loggingimport osimport requestsimport jsonimport timeimport mailjet_restfrom datetime import datetime, timedeltafrom google.cloud import datastorefrom flask import Flaskfrom flask import requestfrom flask import url_forfrom flask import redirectfrom flask import render_templatefrom requests.packages.urllib3.exceptions import InsecureRequestWarningrequests.packages.urllib3.disable_warnings(InsecureRequestWarning)app = Flask(__name__)# [Constans]MAILJET_API_KEY = os.environ['MAILJET_API_KEY']MAILJET_API_SECRET = os.environ['MAILJET_API_SECRET']MAILJET_SENDER = os.environ['MAILJET_SENDER']VISA_RANGE = 5GNIB_RANGE = 5VISA_CHECK_URL = 'https://reentryvisa.inis.gov.ie/website/INISOA/IOA.nsf/(getApps4DT)?openagent&dt={}/{}/{}&type=I&num=1'GNIB_CHECK_URL = 'https://burghquayregistrationoffice.inis.gov.ie/Website/AMSREG/AMSRegWeb.nsf/(getApps4DT)?openagent&dt=' \           '{}/{}/{}&cat=Work&sbcat=All&typ=Renewal'VISA_HOST = 'reentryvisa.inis.gov.ie'GNIB_HOST = 'burghquayregistrationoffice.inis.gov.ie'TOMORROW = datetime.now().date() + timedelta(days=60)HEADERS = {  'user-agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit/537.36 (KHTML, like Gecko)  Chrome/52.0.2743.116 Safari/537.36',  'Connection': 'keep-alive',  'Upgrade-Insecure-Requests': '1',  'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',  'Accept-Language': 'en-US,en;q=0.8,ru;q=0.6,pl;q=0.4,de;q=0.2,uk;q=0.2,it;q=0.2',}def make_header(header, host):  header['host'] = host  return headerdef send_email(to, subject, body):  client = mailjet_rest.Client(    auth=(MAILJET_API_KEY, MAILJET_API_SECRET))  data = {    'FromEmail': MAILJET_SENDER,    'FromName': 'App Engine Flex Mailjet Sample',    'Subject': subject,    'Text-part': body,    'Recipients': [{'Email': to}]  }  result = client.send.create(data=data)  return result.json()# [API objects]datastore_api_client = datastore.Client(os.environ['GCLOUD_PROJECT'])@app.route('/')def visa_page():  if request.method == 'GET':    logging.debug('visa_page requested')    query = datastore_api_client.query(kind='AppointmentSlot', order=('date_time',))    query.add_filter('type', '=', 'Visa')    results = query.fetch()    print(results)    return render_template('Visa_template.html', slots=results)@app.route('/gnib')def gnib_page():  if request.method == 'GET':    logging.debug('gnib_page requested')    query = datastore_api_client.query(kind='AppointmentSlot', order=('date_time',))    query.add_filter('type', '=', 'GNIB')    results = query.fetch()    print(results)    return render_template('GNIB_template.html', slots=results)@app.route('/notification_request', methods=['GET', 'POST'])def notification_request():  if request.method == 'GET':    print('GET on notification_request page')    return render_template('notification_request.html')  if request.method == 'POST':    print('POST on notification_request page')    print(request.form['email'])    print(request.form['start_date'])    print(request.form['appointment_type'])    # Create a key for Notification type entity    Notification_key = datastore_api_client.key('Notification')    # Create that entity    Notification_entity = datastore.entity.Entity(Notification_key)    # Add values into entity    Notification_entity['email'] = request.form['email']    Notification_entity['appointment_type'] = request.form['appointment_type']    Notification_entity['start_date'] = datetime.strptime(request.form['start_date'], "%Y-%m-%d %H:%M")    Notification_entity['end_date'] = datetime.strptime(request.form['end_date'], "%Y-%m-%d %H:%M")    # Put entity into the datastore    datastore_api_client.put(Notification_entity)    # Redirect to the page    return redirect(url_for('notification_request'))@app.route('/notification_check', methods=['GET'])def notification_check():#fn that is invoked by the cron job to send notifications about new slots for the notification  if request.method == 'GET':    print('Cron - GET on notification_check page ')    query = datastore_api_client.query(kind='Notification')    query.keys_only()    query_result_keys = [entity.key for entity in query.fetch()]    for key in query_result_keys:      notification = datastore_api_client.get(key)      query = datastore_api_client.query(kind='AppointmentSlot')      query.add_filter('type', '=', notification['appointment_type'])      query.add_filter('date_time', '>=', notification['start_date'])      query.add_filter('date_time', '<=', notification['end_date'])      list_of_results = [dict(entity) for entity in query.fetch()]      print(list_of_results)      if len(list_of_results) > 0:        print('result is true')        # send email        body = "Hi! There are a new apporintment slots for {} : \n".format(notification['appointment_type'])        for slot in list_of_results:            print(slot['date_time'])            body += "{}\n".format(slot['date_time'])            body += "Register here: {} ".format(VISA_HOST if notification.type == "Visa" else GNIB_HOST)            response = send_email(to=notification.email,                                  subject="New {} Appointment".format(notification.type),                                  body=body                                  )            print(response)        #        #   # delete the request obj from datastore        #   notification.key.delete()      else:        logging.info("Appointment not found")  return 'OK', 200@app.route('/visa_update')def visa_update():  if request.method == 'GET':    # delete all old entities    datastore_api_query = datastore_api_client.query(kind='AppointmentSlot')    datastore_api_query.add_filter('type', '=', 'Visa')    datastore_api_query.keys_only()    keys_to_delete = [entity.key for entity in datastore_api_query.fetch()]    datastore_api_client.delete_multi(keys_to_delete)    for counter in range(VISA_RANGE):      # [Request parameters setup]      date_obj = TOMORROW + timedelta(days=counter)  # add the day delta = counter      day = str(date_obj)[8:10]      month = str(date_obj)[5:7]      year = str(date_obj)[0:4]      print("Visa update request for:" + str(date_obj))      url = VISA_CHECK_URL.format(day, month, year)      print('url == ' + url)      response = requests.get(url, headers=make_header(HEADERS, VISA_HOST), verify=False)      response_json = json.loads(response.text)      if "empty" not in response.text:        # Slots in the response        print(response_json["slots"])        for slot in response_json["slots"]:          # put the slot into datastore          slot_datetime_obj = datetime.strptime(slot['time'], "%d/%m/%Y %I:%M %p")          AppointmentSlot_key = datastore_api_client.key('AppointmentSlot')          AppointmentSlot_entity = datastore.entity.Entity(AppointmentSlot_key)          AppointmentSlot_entity['date_time'] = slot_datetime_obj          AppointmentSlot_entity['type'] = 'Visa'          datastore_api_client.put(AppointmentSlot_entity)      else:        # empty in the response        print(response_json)      # wait for 0.5 sec bettwen each requests - not to ddos :)      time.sleep(0.5)  return 'OK', 200@app.route('/gnib_update')def gnib_update():  if request.method == 'GET':    # delete all old entities    datastore_api_query = datastore_api_client.query(kind='AppointmentSlot')    datastore_api_query.add_filter('type', '=', 'GNIB')    datastore_api_query.keys_only()    keys_to_delete = [entity.key for entity in datastore_api_query.fetch()]    datastore_api_client.delete_multi(keys_to_delete)    for counter in range(GNIB_RANGE):      # [Request parameters setup]      date_obj = TOMORROW + timedelta(days=counter)  # add the day delta = counter      day = str(date_obj)[8:10]      month = str(date_obj)[5:7]      year = str(date_obj)[0:4]      print("GNIB update request for:" + str(date_obj))      url = GNIB_CHECK_URL.format(day, month, year)      print('url == ' + url)      response = requests.get(url, headers=make_header(HEADERS, GNIB_HOST), verify=False)      response_json = json.loads(response.text)      if "empty" not in response.text:        # Slots in the response        print(response_json["slots"])        for slot in response_json["slots"]:          # put the slot into datastore          slot_datetime_obj = datetime.strptime(slot['time'], "%d/%m/%Y %I:%M %p")          AppointmentSlot_key = datastore_api_client.key('AppointmentSlot')          AppointmentSlot_entity = datastore.entity.Entity(AppointmentSlot_key)          AppointmentSlot_entity['date_time'] = slot_datetime_obj          AppointmentSlot_entity['type'] = 'GNIB'          datastore_api_client.put(AppointmentSlot_entity)      else:        # empty in the response        print(response_json)      # wait for 0.5 sec bettwen each requests - not to ddos :)      time.sleep(0.5)  return 'OK', 200@app.errorhandler(500)def server_error(e):  logging.exception('An error occurred during a request.')  return """    An internal error occurred: <pre>{}</pre>    See logs for full stacktrace.    """.format(e), 500if __name__ == '__main__':  # This is used when running locally. Gunicorn is used to run the  # application on Google App Engine. See entrypoint in app.yaml.  app.run(host='127.0.0.1', port=8080, debug=True)# [END app]